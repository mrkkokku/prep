# 넘파이는 다른 라이브러리를 사용하기 위한 전단계이고
# 학습 목표는 넘파이에 발목잡히지 않을 정도로만 하는 것

# 넘파이를 사용하면 다차원배열을 효율적으로 사용할 수 있다.

import numpy as np
import timer
import time


# a = np.array([ ]) 기본적으론 이런식으로 만듦
# 이렇게 만든 a 는 더이상 리스트가 아님, array 가 됨

test = np.array([[11, 12, 13], [21, 22, 23], [31, 32, 33]])

print(test)
''' 이것은 array의 형태이고
[[11 12 13]
 [21 22 23]
 [31 32 33]]
 '''

 # 각 원소에 1씩 더하려면

print(test + 1)
''' # 이런 것을 브로드캐스팅 이라고 한다.
[[12 13 14]
 [22 23 24]
 [32 33 34]]
 '''

# 전체 합 구하기
print( np.sum(test) )

# 전체 평균
print( np.mean(test) )

# 열의 평균
print( np.mean(test, axis=0) )
'''
[21. 22. 23.]
'''

# 행의 평균
print( np.mean(test, axis=1) )
'''
[12. 22. 32.]
'''

# 넘파이는 빠르다
# 내부 코어에 C로 구성된 부분이 있기 때문. (메모리를 효율적으로 쓰게 되어 있음)
# 다차원 배열이 커지면 커질수록 넘파이가 파이썬 속도를 능가함
# 오히려 작은 크기의 배열일 땐 파이썬 기본자료형이 더 빠르기도 함

# 파이썬 기본 리스트와 Numpy Array의 내부 구조 차이점을 말하자면
# nArray의 경우 자료구조안의 모든 자료가 메모리에 연속적으로 배치되며
# 파이썬 리스트의 경우 실제메모리의 주소값을 일렬로 갖고 있어서
# 실제 데이터를 찾으려면 mapping을 한번씩 해야한다.

# 결국 파이썬 리스트는 포인터들의 배열로 구성되어 있음 -> 캐시 활용이 어려움

# ndarray는 타입을 명시하여 원소의 배열로 데이터를 유지
# (예를들면 int형의 경우 4바이트씩 데이터 구간을 딱 정해서 바로 접근)
# 다차원 데이터도 연속된 메모리 공간에 할당 됨



# stride에 대해 알아보자 (간략한 버전)

x = np.array([[1, 2], [3, 4]], dtype=np.int8)
y = x.T

print(x)
'''
[[1 2]
 [3 4]]
'''

print(y)
'''
[[1 3]
 [2 4]]
'''

print(x.strides)
# (2, 1)

print(y.strides)
# (1, 2)

# 이거 이해 안된다, 나중에 추가 공부 하자
'''
x 와 y 모두 
data : 1, 2, 3, 4
dimensions : (2,2)
로 완벽히 동일한데, strides만 다른 것이다
'''

# 어쨋든 transpose하는 작업은 strides 작업으로 하면 컴퓨팅 자원이
# 거의 들지않는 수준으로 처리가 가능하다고 함