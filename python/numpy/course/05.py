# 다차원 배열 다루기 2 

# 이전 시간엔 통계값 구하는 것들을 위주로 했고,
# 이번 시간은 슬라이싱 부터 시작


# 일반적 리스트와 같은 방식으로도 슬라이싱이 가능함.
# 하지만 차원을 고려해줘야 하는 부분이 추가 된 것으로 이해하면 됨

import numpy as np
from numpy.core.defchararray import index

# shape가 (3, 4)인 2차원 배열 생성

a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])

print(a)
'''
[[ 1  2  3  4] 
 [ 5  6  7  8] 
 [ 9 10 11 12]]
 '''


# 슬라이싱 자체가 부분행렬을 구하는 걸로 이해해야함
# (ndarray의 슬라이싱은 부분행렬 구하기의 뜻임)

print( a[0:2, 0:4] )
''' 
슬라이싱이 항상 그렇듯 0부터 1행, 0부터 2열을 의미함, 
또한 실제 행렬과 달리 0행과 0열이 존재함을 알아두자
[[1 2 3 4]
 [5 6 7 8]]
'''


print( a[:2, :4] )
''' 물론 이렇게도 작성가능하고
[[1 2 3 4]
 [5 6 7 8]]
'''

print( a[:, :] )
''' 이렇게도 작성 가능 함
[[ 1  2  3  4]
 [ 5  6  7  8]
 [ 9 10 11 12]]
'''

# 슬라이싱이 특정범위를 잘라서 보는거였다면
# 인덱싱은 특정 원소를 딱 찝어서 보는 것

print( a[0, 0] )  # 이게 사실 a[0][0] 이런식으로 쓴 것과 동일한데, 
                  # 슬라이스와의 연속성을 위해 왼쪽 처럼 쓰자
''' 
1
'''

print( a[[0, 2], ] ) # 이렇게하면 연속되지않은 열을 가져왔다.
                     # 이것은 원본배열의 부분배열이 아님에 유의.
                     # 상당히 가공된 데이터로 봐야한다는 것이다
'''
[[ 1  2  3  4]
 [ 9 10 11 12]]
'''

print( a[:, [0,1,3]] ) #열을 대상으로 연속되지 않은 것을 가져 옴
'''
[[ 1  2  4]
 [ 5  6  8]
 [ 9 10 12]]
'''



# 0번째 행을 인덱싱하는 경우와 슬라이싱하는 경우를 비교해보자

print( a, a.shape, a.ndim ) # a의 정보들
'''
[[ 1  2  3  4]
 [ 5  6  7  8]
 [ 9 10 11 12]] (3, 4) 2
'''


# 슬라이싱만 사용
print( a[0:1, :] ) 
'''
[[1 2 3 4]]
'''

# 슬라이싱만 사용
slicedRow = a[0:1, :]
print( slicedRow, slicedRow.shape, slicedRow.ndim )
'''
[[1 2 3 4]] (1, 4) 2
'''

# 인덱싱과 슬라이싱 혼합사용 
indexedRow = a[0, :] # a[0]과 동일함
print( indexedRow, indexedRow.shape, indexedRow.ndim )
'''
[1 2 3 4] (4,) 1
'''#       ^<-- 여기 뜻은 1차원이라서 그냥 데이터 4개 있다는 뜻임

# 결국
# 인덱싱을 섞게되면 차원이 줄어들 수가 있다.
# 슬라이싱만 쓰면 원본의 차원이 유지 된다.


# 예제 하나 더, 행이아닌 열의 경우를 보자

# 슬라이싱만 사용
slicedCol = a[:, 0:1]
print( slicedCol, slicedCol.shape, slicedCol.ndim )
'''
[[1]
 [5]
 [9]] (3, 1) 2
'''

# 아래와 동일한 코드
# 인덱싱&슬라이싱 혼합 사용
indexedCol = a[:, 0]
print( indexedCol, indexedCol.shape, indexedCol.ndim )
'''
[1 5 9] (3,) 1
'''

# 위와 동일한 코드
# 인덱싱&슬라이싱 혼합 사용
indexedCol2 = a[:, 0]
print( indexedCol2, indexedCol2.shape, indexedCol2.ndim )
'''
[1 5 9] (3,) 1
'''

# 다차원배열간의 연산에서 차원이 달라서 문제가 생기는 경우가 있을 수 있으니
# 특별히 인덱싱을 해야하는 경우가 아니라면 슬라이싱을 사용하는게 좋다



# 값의 복사와 참조
# 인덱싱은 값을 복사해옵니다, 복사된 값을 변경해도 원본값은 변하지 않음

print( a )
'''
[[ 1  2  3  4]
 [ 5  6  7  8]
 [ 9 10 11 12]]
'''

# 인덱싱한것을 b로
b = a[0, 0]
print( b )
'''
1
'''

# b값 수정
b = 100

print( "a[0, 0] : {}".format(a[0, 0]) )
'''
a[0, 0] : 1
'''

print( "b: {}".format(b) )
'''
b: 100
'''


# a를 슬라이스하여 c 생성
c = a[1:3, 1:3]
print( c )
'''
[[ 6  7]
 [10 11]]
'''

c[0, 0] = 100

print(c)
'''
[[100   7]
 [ 10  11]]
'''
print(a)
'''
[[  1   2   3   4]
 [  5 100   7   8]
 [  9  10  11  12]]
'''

# --> a의 값을 건드린적 없는데, 변경되고 말았다.
# 결국 슬라이싱된 배열은 원본배열과 같은 데이터를 참조합니다.
# (값의 복사보단 참조가 빠르기 떄문에 이 점을 알아두자)
# 메모리상에서 보자면 c(0,0)은 a(1,1)과 같다는 것

# 인덱싱은 복사를 하고,
# 슬라이싱은 참조를 한다. 라고 정리.




# boolean 배열 인덱싱
# -> boolean배열 인덱싱을 통해 배열 속 요소를 취사선택할 수 있다
# 특정조건을 만족하게 하는 요소만 선택하고자 할 때 자주 사용 됨

a = np.array([[1,2], [3,4], [5,6]])
print( a )
'''
[[1 2]
 [3 4]
 [5 6]]
'''

bool_idx = (a > 2) # 2보다 큰 a의 요소를 찾습니다
                   # 이 코드는 a와 shape가 같고, bool자료형을 요소로 하는 numpy배열을 반환
                   # bool_idx의 각 요소는 동일한 위치에 있는 a의 요소가 2보다 큰지 알려줌

print(bool_idx)
'''
[[False False]
 [ True  True]
 [ True  True]]
'''

# boolean 배열 인덱싱을 통해 bool_idx에서
# 참값을 가지는 요소로 구성되는
# rank 1인 배열을 구성할 수 있다

print( a[bool_idx] )
'''
[3 4 5 6]
'''

# 위에서 한 모든 작업을 한 문장으로 처리 가능
print( a[a > 2] )
'''
[3 4 5 6]
'''
# 이런 것은 아마 pandas를 다룰 때에 꽤나 쓰게 될 것





# 정수배열 인덱싱

print(a)
'''
[[1 2]
 [3 4]
 [5 6]]
'''

# 정수배열 인덱싱의 예
# 반환되는 배열의 shape는 (3,)
print( a[[0, 1, 2], [0, 1, 0]] ) # 이건 마치 x,y 좌표가 합쳐진 것 마냥
                                 # (0,0), (1,1), (2,0) 값을 리턴하라는 말임
'''
[1 4 5]
'''

# 위의 코드는 이것과 동일하다
print( np.array([a[0, 0], a[1, 1], a[2, 0]]) )
'''
[1 4 5]
'''

# 정수배열 인덱싱을 사용할 때
# 원본 배열의 같은 요소를 재사용할 수 있습니다
print( a[[0, 0], [1, 1]]) 
'''
[2 2]
'''

# 위 예제는 다음과 동일합니다
print( np.array([a[0, 1], a[0, 1]]) )
'''
[2 2]
'''



# 이제 전치(transpose)를 배워본다
# --> 종종 배열의 모양을 바꾸거나 데이터를 처리해야할 때가 있다
# 가장 간단한 예는 행렬의 주 대각선을 기준으로 대칭되는 요소끼리 뒤바꾸는 것
# 이를 전치라고 하며 행렬을 전치하기위해선 간단히 배열객체의 T 속성을 활용하면 됨

x = np.array([[1, 2], [3, 4]])
print(x)
'''
[[1 2]
 [3 4]]
'''

print(x.T)
'''
[[1 3]
 [2 4]]
'''


# 차원이 1차원인 배열을 전치할 경우 아무일도 일어나지 않는다
